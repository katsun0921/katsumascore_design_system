---
description: デザインシステムのパフォーマンス最適化ガイドライン
---

# パフォーマンス最適化ガイドライン

## ビルドパフォーマンス

### Webpack設定
参考: [webpack.config.js](mdc:webpack.config.js)

### 現在の最適化
- `ts-loader`によるTypeScriptコンパイル
- PostCSSとAutoprefixerによるSCSS処理
- MiniCssExtractPluginによるCSS抽出
- file-loaderによるアセット最適化

### 推奨パフォーマンス改善

#### 1. 本番モード最適化
```javascript
// 本番モード最適化を有効化
mode: process.env.NODE_ENV === 'production' ? 'production' : 'development',

// キャッシュバスティング用のコンテンツハッシュを追加
filename: process.env.NODE_ENV === 'production'
  ? '[name].[contenthash:8].js'
  : 'bundle.js',
```

#### 2. コード分割
```javascript
// ベンダーコードを分割
optimization: {
  splitChunks: {
    chunks: 'all',
    cacheGroups: {
      vendor: {
        test: /[\\/]node_modules[\\/]/,
        name: 'vendors',
        chunks: 'all',
      },
    },
  },
},
```

#### 3. Tree Shaking
```javascript
// Tree shakingを有効化
optimization: {
  usedExports: true,
  sideEffects: false,
},
```

## SCSSパフォーマンス

### インポート最適化
- 必要な変数とミックスインのみをインポート
- より良いTree Shakingのために部分インポートを使用

### 最適化されたインポートの例
```scss
// 良い例: 特定のインポート
@use '../../global/variable/colors' as color;
@use '../../global/variable/fontWeight' as fontWeight;

// 避けるべき例: ワイルドカードインポート
@use '../../global/variable/*';
```

### CSS最適化
- ネストの深さを最小化（最大3-4レベル）
- 効率的なセレクターを使用
- 関連するスタイルをグループ化
- 未使用のCSSを削除

## アセット最適化

### 画像最適化
- モダンなフォーマットを使用（WebP、AVIF）
- レスポンシブ画像を実装
- 適切な圧縮を使用
- フォールド下の画像には遅延読み込みを検討

### フォント最適化
- font-display: swapを使用
- 重要なフォントをプリロード
- 可能な限りフォントをサブセット化
- フォールバックとしてシステムフォントを使用

## バンドルサイズ最適化

### JavaScript最適化
- コード分割に動的インポートを使用
- コンポーネントの遅延読み込みを実装
- 未使用の依存関係を削除
- ライブラリにTree Shakingを使用

### CSS最適化
- 未使用のスタイルを削除
- CSSパージングを使用
- CSSバンドルサイズを最小化
- クリティカルCSS抽出を使用

## ランタイムパフォーマンス

### Reactパフォーマンス
- 高コストなコンポーネントにReact.memoを使用
- 高コストな計算にuseMemoとuseCallbackを実装
- 不要な再レンダリングを避ける
- リストに適切なkeyプロパティを使用

### 最適化されたコンポーネントの例
```tsx
import React, { memo, useMemo, useCallback } from 'react';

interface OptimizedButtonProps {
  label: string;
  onClick: () => void;
  items: Array<{ id: string; name: string }>;
}

export const OptimizedButton = memo<OptimizedButtonProps>(({
  label,
  onClick,
  items
}) => {
  // 高コストな計算をメモ化
  const processedItems = useMemo(() => {
    return items.map(item => ({
      ...item,
      processed: true
    }));
  }, [items]);

  // イベントハンドラーをメモ化
  const handleClick = useCallback(() => {
    onClick();
  }, [onClick]);

  return (
    <button onClick={handleClick}>
      {label}
      {processedItems.map(item => (
        <span key={item.id}>{item.name}</span>
      ))}
    </button>
  );
});
```

## WordPress統合パフォーマンス

### テーマ統合
- HTTPリクエストを最小化
- WordPressキャッシュを使用
- データベースクエリを最適化
- 適切なアセットエンキューを実装

### アセット読み込み
- クリティカルCSSをインラインで読み込み
- 非クリティカルJavaScriptを遅延読み込み
- WordPressアセット最適化プラグインを使用
- 適切なキャッシュヘッダーを実装

## 監視とメトリクス

### バンドル分析
- webpack-bundle-analyzerを使用
- バンドルサイズを時間経過で監視
- 大きな依存関係を特定
- パフォーマンス予算を追跡

### パフォーマンスメトリクス
- First Contentful Paint (FCP)
- Largest Contentful Paint (LCP)
- Cumulative Layout Shift (CLS)
- Time to Interactive (TTI)

## ベストプラクティス

### 開発
- より高速なビルドのために開発モードを使用
- デバッグ用にソースマップを有効化
- ホットモジュール置換を使用
- ビルド時間を監視

### 本番
- すべての最適化を有効化
- 本番モードを使用
- 適切なキャッシュを実装
- パフォーマンスメトリクスを監視

### コード品質
- 効率的なコードを記述
- 適切なTypeScript型を使用
- パフォーマンスパターンに従う
- 定期的なパフォーマンス監査

## パフォーマンスチェックリスト

### ビルド最適化
- [ ] 本番モードを有効化
- [ ] コード分割を実装
- [ ] Tree Shakingを使用
- [ ] アセットを最適化
- [ ] バンドルサイズを最小化

### SCSS最適化
- [ ] @useを使用
- [ ] ネストを最小化
- [ ] 未使用スタイルを削除
- [ ] セレクターを最適化

### ランタイム最適化
- [ ] React.memoを使用
- [ ] 遅延読み込みを実装
- [ ] 再レンダリングを最適化
- [ ] 適切なkeyを使用

### WordPress統合
- [ ] アセット読み込みを最適化
- [ ] キャッシュを使用
- [ ] HTTPリクエストを最小化
- [ ] パフォーマンスを監視
